use serde::{Deserialize, Serialize};
use serde_with::{serde_as, BoolFromInt};

#[serde_as]
#[derive(Debug, Serialize, Deserialize)]
pub struct TrackerRequest {
    /// urlencoded 20-byte SHA1 hash of the value of the info key from the Metainfo file.
    pub info_hash: [u8; 20],

    /// urlencoded 20-byte string used as a unique ID for the client, generated by the client at startup.
    pub peer_id: [u8; 20],

    /// The port number that the client is listening on.
    pub port: u16,

    /// The total amount uploaded (since the client sent the 'started' event to the tracker) in base ten ASCII.
    pub uploaded: usize,

    /// The total amount downloaded (since the client sent the 'started' event to the tracker) in base ten ASCII
    pub downloaded: usize,

    /// The number of bytes this client still has to download in base ten ASCII.
    pub left: usize,

    ///  Setting this to 1 indicates that the client accepts a compact response. The peers list is replaced by a peers string with 6 bytes per peer.
    #[serde_as(as = "BoolFromInt")]
    pub compact: bool,

    /// If specified, must be one of started, completed, stopped,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub event: Option<TrackerEvent>,

    /// The true IP address of the client machine, in dotted quad format or rfc3513 defined hexed IPv6 address.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ip: Option<std::net::IpAddr>,

    /// Number of peers that the client would like to receive from the tracker.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub numwant: Option<usize>,

    ///  An additional identification that is not shared with any other peers. It is intended to allow a client to prove their identity should their IP address change.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,

    /// If a previous announce contained a tracker id, it should be set here
    #[serde(skip_serializing_if = "Option::is_none")]
    pub trackerid: Option<String>,
}

#[derive(Debug, PartialEq, Serialize, Deserialize)]
pub enum TrackerEvent {
    #[serde(rename = "started")]
    Started,
    #[serde(rename = "completed")]
    Completed,
    #[serde(rename = "stopped")]
    Stopped,
}

#[derive(PartialEq, Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrackerResponse {
    Failure(TrackerResponseFailure),
    Success(TrackerResponseSuccess),
}

#[derive(PartialEq, Debug, Serialize, Deserialize)]
pub struct TrackerResponseFailure {
    /// The value is a human-readable error message as to why the request failed
    #[serde(rename = "failure reason")]
    pub failure_reason: String,
}

#[derive(PartialEq, Debug, Serialize, Deserialize)]
pub struct TrackerResponseSuccess {
    /// number of peers with the entire file, i.e. seeders
    pub complete: usize,

    /// number of non-seeder peers, aka "leechers"
    pub incomplete: usize,

    /// Interval in seconds that the client should wait between sending regular requests to the tracker
    pub interval: usize,

    /// Minimum announce interval. If present clients must not reannounce more frequently than this.
    #[serde(rename = "min interval")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub min_interval: Option<usize>,

    /// list of peers
    pub peers: Vec<TrackerPeer>,

    /// A string that the client should send back on its next announcements. If absent and a previous announce sent a tracker id, do not discard the old value; keep using it.
    #[serde(rename = "tracker id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tracker_id: Option<String>,

    /// Similar to failure reason, but the response still gets processed normally. The warning message is shown just like an error.
    #[serde(rename = "warning message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub warning_message: Option<String>,
}

#[derive(PartialEq, Debug, Serialize, Deserialize)]
pub struct TrackerPeer {
    /// peer's IP address either IPv4, IPv6, or DNS name
    #[serde(with = "as_peer_address")]
    pub ip: TrackerPeerAddress,

    /// peer's self-selected ID, as described above for the tracker request (string)
    #[serde(rename = "peer id")]
    pub peer_id: String,

    /// peer's port number
    pub port: u16,
}

#[derive(PartialEq, Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TrackerPeerAddress {
    IP(std::net::IpAddr),
    DNS(String),
}

mod as_peer_address {
    use super::TrackerPeerAddress;
    use serde::{ser::Serialize, Deserialize, Deserializer};

    pub fn deserialize<'de, D>(deserializer: D) -> Result<TrackerPeerAddress, D::Error>
    where
        D: Deserializer<'de>,
    {
        let value: String = Deserialize::deserialize(deserializer)?;
        match value.parse::<std::net::IpAddr>() {
            Ok(ip) => Ok(TrackerPeerAddress::IP(ip)),
            Err(_) => Ok(TrackerPeerAddress::DNS(value)),
        }
    }

    pub fn serialize<S>(data: &TrackerPeerAddress, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match data {
            TrackerPeerAddress::IP(ip) => ip.serialize(serializer),
            TrackerPeerAddress::DNS(dns) => dns.serialize(serializer),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::{BufReader, Cursor};
    use tforge_bencode::{deserializer::from_reader, serializer::from_writer};

    // #[test]
    // fn test_tracker_request_urlencode() {
    //     let request = TrackerRequest {
    //         info_hash: b"fake-info-hash-12345".to_owned(),
    //         peer_id: b"fake-peer-id-1234567".to_owned(),
    //         port: 1234,
    //         uploaded: 123,
    //         downloaded: 456,
    //         left: 789,
    //         compact: true,
    //         event: Some(TrackerEvent::Started),
    //         ip: Some(std::net::IpAddr::V4(std::net::Ipv4Addr::new(127, 0, 0, 1))),
    //         numwant: Some(10),
    //         key: Some("key".to_string()),
    //         trackerid: Some("trackerid".to_string()),
    //     };

    //     let encoded = serde_urlencoded::to_string(&request).unwrap();

    //     assert_eq!(
    //         encoded,
    //         serde_urlencoded::to_string(&[
    //             (
    //                 "info_hash",
    //                 form_urlencoded::byte_serialize(b"fake-info-hash-12345")
    //                     .collect::<String>()
    //                     .as_str()
    //             ),
    //             (
    //                 "peer_id",
    //                 form_urlencoded::byte_serialize(b"fake-peer-id-1234567")
    //                     .collect::<String>()
    //                     .as_str()
    //             ),
    //             ("port", "1234"),
    //             ("uploaded", "123"),
    //             ("downloaded", "456"),
    //             ("left", "789"),
    //             ("compact", "1"),
    //             ("event", "started"),
    //             ("ip", "127.0.0.1"),
    //             ("numwant", "10"),
    //             ("key", "key"),
    //             ("trackerid", "trackerid"),
    //         ])
    //         .unwrap()
    //     );
    // }

    // #[test]
    // fn test_tracker_request_urldecode() {
    //     let encoded = serde_urlencoded::to_string(&[
    //         (
    //             "info_hash",
    //             form_urlencoded::byte_serialize(b"fake-info-hash-12345")
    //                 .collect::<String>()
    //                 .as_str(),
    //         ),
    //         (
    //             "peer_id",
    //             form_urlencoded::byte_serialize(b"fake-peer-id-1234567")
    //                 .collect::<String>()
    //                 .as_str(),
    //         ),
    //         ("port", "1234"),
    //         ("uploaded", "123"),
    //         ("downloaded", "456"),
    //         ("left", "789"),
    //         ("compact", "1"),
    //         ("event", "started"),
    //         ("ip", "127.0.0.1"),
    //         ("numwant", "10"),
    //         ("key", "key"),
    //         ("trackerid", "trackerid"),
    //     ]);

    //     let request: TrackerRequest = serde_urlencoded::from_str(&encoded.unwrap()).unwrap();

    //     assert_eq!(request.info_hash, b"fake-info-hash-12345".to_owned());
    //     assert_eq!(request.peer_id, b"fake-peer-id-1234567".to_owned());
    //     assert_eq!(request.port, 1234);
    //     assert_eq!(request.uploaded, 123);
    //     assert_eq!(request.downloaded, 456);
    //     assert_eq!(request.left, 789);
    //     assert_eq!(request.compact, true);
    //     assert_eq!(request.event, Some(TrackerEvent::Started));
    //     assert_eq!(
    //         request.ip,
    //         Some(std::net::IpAddr::V4(std::net::Ipv4Addr::new(127, 0, 0, 1)))
    //     );
    //     assert_eq!(request.numwant, Some(10));
    //     assert_eq!(request.key, Some("key".to_string()));
    //     assert_eq!(request.trackerid, Some("trackerid".to_string()));
    // }

    #[test]
    fn test_tracker_success_response_bencode() {
        let response = TrackerResponse::Success(TrackerResponseSuccess {
            complete: 1,
            incomplete: 2,
            interval: 3,
            min_interval: Some(4),
            peers: vec![
                TrackerPeer {
                    ip: TrackerPeerAddress::IP(std::net::IpAddr::V4(std::net::Ipv4Addr::new(
                        127, 0, 0, 1,
                    ))),
                    peer_id: "peer_id".to_string(),
                    port: 1234,
                },
                TrackerPeer {
                    ip: TrackerPeerAddress::DNS("example.com".to_string()),
                    peer_id: "peer_id".to_string(),
                    port: 1234,
                },
            ],
            tracker_id: Some("tracker_id".to_string()),
            warning_message: Some("warning_message".to_string()),
        });

        let mut writer = Vec::new();
        let mut serializer = from_writer(&mut writer);
        response.serialize(&mut serializer).unwrap();

        let mut reader = BufReader::new(Cursor::new(writer));
        let result: TrackerResponse = from_reader(&mut reader).unwrap();

        assert_eq!(result, response);
    }

    #[test]
    fn test_tracker_failure_response_bencode() {
        let response = TrackerResponse::Failure(TrackerResponseFailure {
            failure_reason: "failure_reason".to_string(),
        });

        let mut writer = Vec::new();
        let mut serializer = from_writer(&mut writer);
        response.serialize(&mut serializer).unwrap();

        let mut reader = BufReader::new(Cursor::new(writer));
        let result: TrackerResponse = from_reader(&mut reader).unwrap();

        assert_eq!(result, response);
    }
}
